input {
  beats {
    port => 5044
  }
}

filter {
  # Determine log source based on fields
  if [source] =~ /suricata/ or [fields][log_type] == "suricata" {
    # Suricata EVE JSON logs
    json {
      source => "message"
      skip_on_invalid_json => true
    }
    
    # Add log source tag
    mutate {
      add_field => { "log_source" => "suricata" }
    }
    
    # Process Suricata events
    if [event_type] {
      mutate {
        add_field => { "attack_type" => "Network Security Event" }
      }
      
      # Extract key Suricata fields
      if [src_ip] {
        mutate {
          copy => { "src_ip" => "client_ip" }
        }
      }
      
      if [dest_ip] {
        mutate {
          copy => { "dest_ip" => "destination_ip" }
        }
      }
      
      # Map Suricata alert categories
      if [alert] {
        mutate {
          add_field => { "attack_type" => "%{[alert][category]}" }
        }
      }
    }
  } else {
    # ModSecurity logs (existing processing)
    json {
      source => "message"
      skip_on_invalid_json => true
    }
    
    mutate {
      add_field => { "log_source" => "modsecurity" }
    }
  }

  # If a transaction was logged, process it (ModSecurity)
  if [transaction] {
    # The full, original log is nested under the 'modsec' field
    mutate {
      rename => { "transaction" => "modsec" }
    }

    # Use the 'date' filter to correctly set the event timestamp
    date {
      match => [ "[modsec][time_stamp]", "ISO8601" ]
      target => "@timestamp"
      remove_field => [ "[modsec][time_stamp]" ]
    }

    # Extract key fields to the top level for easy access
    mutate {
      copy => {
        "[modsec][client_ip]" => "client_ip"
        "[modsec][request][uri]" => "request_uri"
        "[modsec][request][method]" => "http_method"
        "[modsec][request][http_version]" => "http_version"
        "[modsec][response][http_code]" => "response_code"
        "[modsec][unique_id]" => "unique_id"
        "[modsec][request][headers][user-agent]" => "user_agent"
      }
    }

    # Extract attack type from ModSecurity messages
    # In ModSecurity JSON logs, messages is an array, and each message has details.tags
    # We need to iterate through messages and extract tags
    if [modsec][messages] {
      ruby {
        code => "
          attack_types = []
          if event.get('[modsec][messages]').is_a?(Array)
            event.get('[modsec][messages]').each do |msg|
              if msg.is_a?(Hash) && msg['details']
                tags = msg['details']['tags']
                if tags.is_a?(Array)
                  tags.each do |tag|
                    attack_types << tag unless attack_types.include?(tag)
                  end
                end
              end
            end
          end
          
          # Map tags to human-readable attack types
          attack_type_map = {
            'attack-sqli' => 'SQL Injection',
            'attack-xss' => 'Cross-Site Scripting',
            'attack-lfi' => 'Local File Inclusion',
            'attack-rfi' => 'Remote File Inclusion',
            'attack-injection-php' => 'PHP Injection',
            'attack-injection-nodejs' => 'Node.js Injection',
            'attack-injection-java' => 'Java Injection',
            'attack-fixation-session' => 'Session Fixation',
            'attack-protocol' => 'Protocol Violation',
            'attack-scanner' => 'Security Scanner',
            'leakage-data' => 'Information Leakage',
            'attack-rce' => 'Remote Code Execution',
            'attack-fileupload' => 'File Upload Attack',
            'attack-authentication' => 'Authentication Bypass',
            'attack-session' => 'Session Attack',
            'dos-protection' => 'Brute Force / Rate Limiting',
            'REQUEST-912-DOS-PROTECTION' => 'Brute Force / Rate Limiting',
            'REQUEST-913-SCANNER-DETECTION' => 'Security Scanner / Brute Force'
          }
          
          # Find the first mappable attack type from tags
          attack_type = 'Unknown/Analyst Review'
          attack_types.each do |tag|
            if attack_type_map.key?(tag)
              attack_type = attack_type_map[tag]
              break
            end
          end
          
          # Detect brute force and scanning patterns
          # Only if no attack type was detected from tags
          if attack_type == 'Unknown/Analyst Review'
            uri = event.get('[modsec][request][uri]') || ''
            response_code = event.get('[modsec][response][http_code]') || ''
            user_agent = event.get('[modsec][request][headers][user-agent]') || ''
            
            # Pattern detection for brute force: login endpoints with failed auth
            if uri.match(/\/login\.php|\/vulnerabilities\/brute|\/vulnerabilities\/api\/.*\/login/i) && 
               (response_code == '401' || response_code == '403')
              attack_type = 'Potential Brute Force'
            end
            
            # Pattern detection for scanning: suspicious user agents
            if user_agent.match(/nmap|nikto|dirb|gobuster|dirbuster|wfuzz|sqlmap|burpsuite|acunetix|nessus|openvas|masscan|zmap/i)
              attack_type = 'Security Scanner Detected'
              event.set('scanner_tool', user_agent)
            end
            
            # Pattern detection for scanning: enumeration attempts (404 errors on common paths)
            if response_code == '404' && uri.match(/\/admin|\/wp-admin|\/phpmyadmin|\/\.git|\/\.env|\/backup|\/test|\/api|\/config/i)
              attack_type = 'Potential Directory Enumeration'
            end
          end
          
          event.set('attack_type', attack_type)
          event.set('detected_tags', attack_types) if attack_types.any?
        "
      }
    } else {
      mutate {
        add_field => { "attack_type" => "No Attack Detected" }
      }
    }
  }
}

output {
  # Route to different indices based on log source
  if [log_source] == "suricata" {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "suricata-logs-%{+YYYY.MM.dd}"
    }
  } else if [log_source] == "modsecurity" {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "modsec-logs-%{+YYYY.MM.dd}"
    }
  } else {
    # Default index for unknown sources
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "soc-logs-%{+YYYY.MM.dd}"
    }
  }

  # Also print to stdout for easy debugging
  stdout {
    codec => rubydebug
  }
}
