input {
  beats {
    port => 5044
  }
}

filter {
  # Parse the incoming JSON from ModSecurity
  json {
    source => "message"
    skip_on_invalid_json => true
  }

  # If a transaction was logged, process it
  if [transaction] {
    # The full, original log is nested under the 'modsec' field
    mutate {
      rename => { "transaction" => "modsec" }
    }

    # Use the 'date' filter to correctly set the event timestamp
    date {
      match => [ "[modsec][time_stamp]", "ISO8601" ]
      target => "@timestamp"
      remove_field => [ "[modsec][time_stamp]" ]
    }

    # Extract key fields to the top level for easy access
    mutate {
      copy => {
        "[modsec][client_ip]" => "client_ip"
        "[modsec][request][uri]" => "request_uri"
        "[modsec][request][method]" => "http_method"
        "[modsec][request][http_version]" => "http_version"
        "[modsec][response][http_code]" => "response_code"
        "[modsec][unique_id]" => "unique_id"
      }
    }

    # Extract attack type from ModSecurity messages
    # In ModSecurity JSON logs, messages is an array, and each message has details.tags
    # We need to iterate through messages and extract tags
    if [modsec][messages] {
      ruby {
        code => "
          attack_types = []
          if event.get('[modsec][messages]').is_a?(Array)
            event.get('[modsec][messages]').each do |msg|
              if msg.is_a?(Hash) && msg['details']
                tags = msg['details']['tags']
                if tags.is_a?(Array)
                  tags.each do |tag|
                    attack_types << tag unless attack_types.include?(tag)
                  end
                end
              end
            end
          end
          
          # Map tags to human-readable attack types
          attack_type_map = {
            'attack-sqli' => 'SQL Injection',
            'attack-xss' => 'Cross-Site Scripting',
            'attack-lfi' => 'Local File Inclusion',
            'attack-rfi' => 'Remote File Inclusion',
            'attack-injection-php' => 'PHP Injection',
            'attack-injection-nodejs' => 'Node.js Injection',
            'attack-injection-java' => 'Java Injection',
            'attack-fixation-session' => 'Session Fixation',
            'attack-protocol' => 'Protocol Violation',
            'attack-scanner' => 'Security Scanner',
            'leakage-data' => 'Information Leakage',
            'attack-rce' => 'Remote Code Execution',
            'attack-fileupload' => 'File Upload Attack',
            'attack-authentication' => 'Authentication Bypass',
            'attack-session' => 'Session Attack'
          }
          
          # Find the first mappable attack type
          attack_type = 'Unknown/Analyst Review'
          attack_types.each do |tag|
            if attack_type_map.key?(tag)
              attack_type = attack_type_map[tag]
              break
            end
          end
          
          event.set('attack_type', attack_type)
          event.set('detected_tags', attack_types) if attack_types.any?
        "
      }
    } else {
      mutate {
        add_field => { "attack_type" => "No Attack Detected" }
      }
    }
  }
}

output {
  # Send the enriched log to Elasticsearch
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "modsec-logs-%{+YYYY.MM.dd}"
  }

  # Also print to stdout for easy debugging
  stdout {
    codec => rubydebug
  }
}
