<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terminologia Crittografica</title>
    <link rel="stylesheet" href="../style.css">
    <style>
        .demo-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .back-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            text-decoration: none;
            margin-bottom: 20px;
            transition: all 0.3s;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(-5px);
        }

        /* Sezioni */
        .concept-section {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 16px;
            padding: 25px;
            margin: 25px 0;
            border: 2px solid #3b82f6;
        }

        .concept-section h2 {
            margin: 0 0 10px 0;
            color: #3b82f6;
        }

        /* Term cards */
        .term-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .term-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 20px;
            border-left: 4px solid #3b82f6;
            transition: all 0.3s;
        }

        .term-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(59, 130, 246, 0.3);
        }

        .term-card h3 {
            margin: 0 0 12px 0;
            color: #3b82f6;
            font-size: 1.3em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .term-card .term-code {
            font-family: 'Courier New', monospace;
            background: rgba(59, 130, 246, 0.2);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .term-card .term-explanation {
            color: #94a3b8;
            line-height: 1.6;
            margin-top: 10px;
        }

        .term-card .term-example {
            margin-top: 15px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .term-card .term-category {
            display: inline-block;
            padding: 4px 10px;
            background: rgba(59, 130, 246, 0.2);
            border-radius: 12px;
            font-size: 0.8em;
            margin-top: 10px;
            color: #3b82f6;
        }

        /* Search */
        .search-box {
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
        }

        .search-box input {
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.4);
            color: white;
        }

        .search-box input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        /* Category filter */
        .category-filter {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }

        .category-btn {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            color: #94a3b8;
            cursor: pointer;
            transition: all 0.2s;
        }

        .category-btn:hover,
        .category-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }
    </style>
</head>

<body>
    <div class="demo-container">
        <a href="0-intro.html" class="back-btn">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
            Torna all'introduzione
        </a>

        <h1 class="title">üìö Terminologia Crittografica</h1>
        <div class="subtitle">Dizionario completo: tutti i termini tecnici spiegati in modo semplice</div>

        <div class="search-box">
            <input type="text" id="search-input" placeholder="üîç Cerca un termine..." onkeyup="filterTerms()">
        </div>

        <div class="category-filter">
            <button class="category-btn active" onclick="filterByCategory('all')">Tutti</button>
            <button class="category-btn" onclick="filterByCategory('math')">Matematica</button>
            <button class="category-btn" onclick="filterByCategory('algorithms')">Algoritmi</button>
            <button class="category-btn" onclick="filterByCategory('protocols')">Protocolli</button>
            <button class="category-btn" onclick="filterByCategory('operations')">Operazioni</button>
            <button class="category-btn" onclick="filterByCategory('security')">Sicurezza</button>
        </div>

        <div class="concept-section">
            <h2>üìñ Glossario Completo</h2>
            <div class="term-grid" id="terms-container">
                <!-- Terms will be added by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        const terms = [
            {
                term: "‚â° (Congruenza)",
                code: "a ‚â° b (mod n)",
                category: "math",
                explanation: "Due numeri sono 'congruenti modulo n' se hanno lo stesso resto quando divisi per n. Si legge 'a √® congruo a b modulo n'.",
                example: "7 ‚â° 2 (mod 5) perch√© 7 mod 5 = 2 e 2 mod 5 = 2",
                details: "La congruenza √® fondamentale in aritmetica modulare, usata in RSA, Diffie-Hellman e molti altri algoritmi crittografici."
            },
            {
                term: "√ó (Moltiplicazione)",
                code: "a √ó b",
                category: "math",
                explanation: "Il simbolo '√ó' indica sempre moltiplicazione in matematica. In crittografia, spesso si usa anche '¬∑' o semplicemente 'ab'.",
                example: "œÜ(n) = n √ó (1 - 1/p‚ÇÅ) √ó (1 - 1/p‚ÇÇ)",
                details: "In formule matematiche, '√ó' √® sempre moltiplicazione, mai altro significato."
            },
            {
                term: "œÜ(n) - Funzione di Eulero",
                code: "œÜ(n) = n √ó (1 - 1/p‚ÇÅ) √ó (1 - 1/p‚ÇÇ) √ó ... √ó (1 - 1/p‚Çñ)",
                category: "math",
                explanation: "Conta quanti numeri tra 1 e n-1 sono coprimi con n (cio√® hanno GCD = 1 con n). Fondamentale per RSA.",
                example: "œÜ(12) = 12 √ó (1-1/2) √ó (1-1/3) = 12 √ó 1/2 √ó 2/3 = 4",
                details: "Se n = p √ó q (con p e q primi), allora œÜ(n) = (p-1)(q-1). Questa √® la formula usata in RSA per calcolare la chiave privata."
            },
            {
                term: "TLS (Transport Layer Security)",
                code: "TLS 1.3",
                category: "protocols",
                explanation: "Protocollo che cifra le comunicazioni su internet. √à quello che rende 'HTTPS' sicuro (la 'S' sta per Secure).",
                example: "Quando visiti un sito con https://, stai usando TLS per proteggere i tuoi dati",
                details: "TLS 1.3 √® la versione moderna (2018). Usa ECDH per scambio chiavi, AES-GCM per cifratura, e SHA-256 per autenticazione."
            },
            {
                term: "S-Box (Substitution Box)",
                code: "S-box",
                category: "operations",
                explanation: "Una tabella che sostituisce ogni byte con un altro byte. In AES, la S-box √® fissa e pubblica, ma √® non-lineare (difficile da invertire).",
                example: "In AES, byte 0x00 ‚Üí S-box ‚Üí 0x63. Ogni byte viene sostituito con un valore dalla tabella.",
                details: "La S-box fornisce 'confusione': rende difficile dedurre la chiave anche conoscendo input e output. √à biunivoca: ogni input ha un output unico."
            },
            {
                term: "GF(2‚Å∏) - Campo di Galois",
                code: "GF(2‚Å∏)",
                category: "math",
                explanation: "Un 'campo matematico' con 256 elementi (2‚Å∏ = 256). In AES, ogni byte √® trattato come un elemento di GF(2‚Å∏).",
                example: "In GF(2‚Å∏), le operazioni (somma, moltiplicazione) funzionano in modo speciale, usando aritmetica modulo un polinomio.",
                details: "GF(2‚Å∏) permette di fare operazioni matematiche sui byte in modo che ogni operazione abbia sempre un risultato valido (un byte). Usato in MixColumns di AES."
            },
            {
                "term": "Campo (Field)",
                "code": "Field",
                "category": "math",
                "explanation": "Una struttura matematica in cui puoi sommare, sottrarre, moltiplicare e dividere (tranne per zero) e ogni operazione √® sempre ben definita.",
                "example": "I numeri reali ‚Ñù e i numeri razionali ‚Ñö sono campi: ogni numero ha un inverso moltiplicativo diverso da zero.",
                "details": "Un campo √® un insieme con due operazioni (somma e prodotto) che soddisfano propriet√† precise: associativit√†, commutativit√†, distributivit√†, esistenza di 0 e 1, inversi additivi e moltiplicativi. Nei campi finiti (es. Galois Field GF(p)), tutte le operazioni avvengono modulo un numero primo."
            },
            {
                "term": "Anello (Ring)",
                "code": "Ring",
                "category": "math",
                "explanation": "Una struttura matematica che permette somma e moltiplicazione, ma non garantisce l‚Äôesistenza dell‚Äôinverso moltiplicativo.",
                "example": "Gli interi ‚Ñ§ formano un anello: puoi sommare, sottrarre e moltiplicare, ma non puoi sempre dividere (es. 2 non divide 3 in ‚Ñ§).",
                "details": "Un anello ha un'operazione di somma (con identit√† e inversi) e un'operazione di moltiplicazione chiusa e distributiva sulla somma. Non richiede che ogni elemento abbia un inverso rispetto alla moltiplicazione. Se il prodotto √® commutativo, si parla di anello commutativo; se ha identit√† moltiplicativa, si parla di anello unitario."
            },
            {
                "term": "Gruppo",
                "code": "Group",
                "category": "math",
                "explanation": "Una struttura con una sola operazione (es. somma) che ha inversi e un'identit√† e soddisfa alcune propriet√† di base.",
                "example": "Gli interi con l‚Äôoperazione somma (‚Ñ§, +) formano un gruppo: 0 √® l‚Äôidentit√†, e ogni numero ha un inverso (es. l‚Äôinverso di 3 √® ‚àí3).",
                "details": "Un gruppo richiede quattro propriet√†: chiusura, associativit√†, identit√† e inverso. Se l‚Äôoperazione √® commutativa, si parla di gruppo abeliano. I gruppi sono i 'mattoni' con cui si costruiscono anelli e campi."
            },
            {
                "term": "Corpo Finito / Campo Finito",
                "code": "GF(p‚Åø)",
                "category": "math",
                "explanation": "Un campo con un numero finito di elementi. Usato mas¬≠sic¬≠cia¬≠men¬≠te in crittografia, coding theory e AES.",
                "example": "GF(2‚Å∏) contiene esattamente 256 elementi. Le operazioni si fanno modulo un polinomio irriducibile di grado 8.",
                "details": "Un campo finito esiste solo se il numero di elementi √® p‚Åø, dove p √® un numero primo e n un intero positivo. Ogni GF(p‚Åø) ha una struttura algebrica costruita su polinomi modulo un polinomio irriducibile. Fornisce sempre un inverso per ogni elemento non nullo, caratteristica cruciale per la crittografia simmetrica e asimmetrica."
            }

            {
                term: "ECB Mode (Electronic Codebook)",
                code: "AES-ECB",
                category: "algorithms",
                explanation: "Modalit√† di cifratura dove ogni blocco viene cifrato indipendentemente. √à INSICURO perch√© blocchi identici producono ciphertext identici.",
                example: "Se cifri 'HELLO HELLO' con ECB, i blocchi 'HELL' producono lo stesso ciphertext ‚Üí pattern visibili!",
                details: "Il famoso 'ECB Penguin': un'immagine cifrata con ECB mostra ancora il pinguino perch√© zone uniformi producono pattern. MAI usare ECB in produzione!"
            },
            {
                term: "Preimage",
                code: "preimage attack",
                category: "security",
                explanation: "Trovare un input che produce un hash specifico. Se un hash √® 'preimage-resistant', √® computazionalmente impossibile trovare l'input originale.",
                example: "Dato hash SHA-256 'abc123...', trovare un input che produce questo hash richiede ~2^256 tentativi (impossibile!).",
                details: "Per SHA-256, un attacco preimage richiede ~2^256 operazioni. √à una delle tre propriet√† di sicurezza degli hash crittografici."
            },
            {
                term: "IV (Initialization Vector)",
                code: "IV",
                category: "operations",
                explanation: "Un numero casuale usato all'inizio della cifratura per rendere ogni cifratura unica, anche con lo stesso messaggio e chiave.",
                example: "In CBC mode, ogni messaggio usa un IV diverso. Se cifri 'Ciao' due volte con stessa chiave ma IV diversi, ottieni ciphertext diversi.",
                details: "L'IV NON √® segreto (pu√≤ essere pubblico), ma DEVE essere unico per ogni messaggio. Se riutilizzi IV con stessa chiave, comprometti la sicurezza."
            },
            {
                term: "Nonce (Number used ONCE)",
                code: "nonce",
                category: "operations",
                explanation: "Un numero usato UNA SOLA VOLTA. Simile all'IV, ma pi√π generale. Usato in GCM, CTR, e altri protocolli.",
                example: "In AES-GCM, ogni messaggio ha un nonce unico. Se riutilizzi lo stesso nonce con stessa chiave, la sicurezza si rompe.",
                details: "Nonce = 'Number used ONCE'. Deve essere unico, ma non necessariamente casuale (pu√≤ essere un contatore). Mai riutilizzare!"
            },
            {
                term: "AEAD (Authenticated Encryption with Associated Data)",
                code: "AEAD",
                category: "algorithms",
                explanation: "Cifratura che fornisce sia confidenzialit√† (cifra) che autenticazione (verifica integrit√†) in un'unica operazione.",
                example: "AES-GCM √® AEAD: cifra il messaggio E produce un tag di autenticazione che verifica che il messaggio non sia stato modificato.",
                details: "AEAD √® meglio di cifratura + MAC separati perch√© √® pi√π veloce e meno soggetto a errori. GCM, ChaCha20-Poly1305 sono AEAD."
            },
            {
                term: "GCM (Galois/Counter Mode)",
                code: "AES-GCM",
                category: "algorithms",
                explanation: "Modalit√† di cifratura AES che fornisce sia cifratura che autenticazione (AEAD). √à la modalit√† raccomandata oggi.",
                example: "TLS 1.3 usa AES-GCM. Ogni messaggio ha un nonce unico e produce ciphertext + tag di autenticazione.",
                details: "GCM √® veloce, parallelizzabile, e sicuro. Standard in TLS 1.3. Usa sempre GCM quando possibile invece di CBC o CTR."
            },
            {
                term: "CBC (Cipher Block Chaining)",
                code: "AES-CBC",
                category: "algorithms",
                explanation: "Modalit√† dove ogni blocco √® cifrato usando il ciphertext del blocco precedente. Richiede IV casuale e MAC separato.",
                example: "Blocco 1 cifrato con chiave. Blocco 2 cifrato con chiave XOR ciphertext blocco 1. E cos√¨ via.",
                details: "CBC √® pi√π vecchio di GCM. Richiede padding e un MAC separato (HMAC-SHA256) per autenticazione. Usa solo se GCM non disponibile."
            },
            {
                term: "CTR (Counter Mode)",
                code: "AES-CTR",
                category: "algorithms",
                explanation: "Trasforma AES in uno stream cipher. Non richiede padding. Ogni blocco usa un contatore diverso.",
                example: "Cifra un contatore (0, 1, 2, 3...) con AES, poi fa XOR con il plaintext. Risultato: stream cipher.",
                details: "CTR √® veloce e non richiede padding, ma serve un MAC separato per autenticazione. Meno usato di GCM oggi."
            },
            {
                term: "HMAC (Hash-based Message Authentication Code)",
                code: "HMAC-SHA256",
                category: "security",
                explanation: "Un codice di autenticazione che usa una funzione hash (es. SHA-256) per verificare che un messaggio non sia stato modificato.",
                example: "HMAC-SHA256(messaggio, chiave) produce un tag. Se il messaggio cambia, il tag cambia ‚Üí rileva modifiche.",
                details: "HMAC √® usato quando la cifratura non include autenticazione (es. CBC, CTR). Sempre verifica il tag prima di decifrare!"
            },
            {
                term: "PKCS#7 Padding",
                code: "PKCS#7",
                category: "operations",
                explanation: "Metodo per riempire un messaggio fino a multiplo della dimensione del blocco (es. 16 byte per AES).",
                example: "Messaggio di 10 byte ‚Üí aggiungi 6 byte con valore 6. Messaggio di 16 byte ‚Üí aggiungi 16 byte con valore 16.",
                details: "Il padding dice quanti byte sono stati aggiunti. Se mancano N byte, aggiungi N byte tutti con valore N. Usato in CBC, non in GCM/CTR."
            },
            {
                term: "ECDH (Elliptic Curve Diffie-Hellman)",
                code: "ECDH",
                category: "algorithms",
                explanation: "Versione di Diffie-Hellman che usa curve ellittiche invece di esponenziazione modulare. Stessa sicurezza con chiavi pi√π corte.",
                example: "Alice e Bob scambiano chiavi pubbliche su una curva ellittica. Calcolano una chiave condivisa senza mai comunicarla direttamente.",
                details: "ECDH P-256 (256 bit) offre sicurezza equivalente a DH classico 2048 bit. Usato in TLS 1.3, Signal, Bitcoin."
            },
            {
                term: "ECDLP (Elliptic Curve Discrete Logarithm Problem)",
                code: "ECDLP",
                category: "math",
                explanation: "Il problema matematico su cui si basa ECDH: dati P e Q = k √ó P, trovare k √® computazionalmente difficile.",
                example: "Se conosci il punto P e il punto Q = 5 √ó P, trovare che k=5 richiede ~2^128 operazioni (impossibile!).",
                details: "ECDLP √® pi√π difficile del DLP classico ‚Üí chiavi pi√π corte. Per P-256, servono ~2^128 operazioni per risolvere ECDLP."
            },
            {
                term: "RSA (Rivest-Shamir-Adleman)",
                code: "RSA",
                category: "algorithms",
                explanation: "Algoritmo di crittografia asimmetrica basato sulla difficolt√† di fattorizzare numeri grandi in due primi.",
                example: "Chiave pubblica: (n, e). Chiave privata: (n, d). Cifra: c = m^e mod n. Decifra: m = c^d mod n.",
                details: "RSA 2048 bit √® sicuro oggi. Basato su: fattorizzare n = p √ó q √® difficile. Usato per firme digitali e scambio chiavi."
            },
            {
                term: "SHA-256 (Secure Hash Algorithm 256)",
                code: "SHA-256",
                category: "algorithms",
                explanation: "Funzione hash che produce sempre un output di 256 bit (32 byte), indipendentemente dalla dimensione dell'input.",
                example: "SHA-256('Ciao') = a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e (sempre 64 caratteri hex).",
                details: "SHA-256 √® deterministico, veloce, e irreversibile. Usato per integrit√† file, firme digitali, Git commits, Bitcoin mining."
            },
            {
                term: "bcrypt",
                code: "bcrypt",
                category: "algorithms",
                explanation: "Algoritmo di hashing lento progettato per password. Basato su Blowfish, con cost factor configurabile.",
                example: "bcrypt('password123', cost=10) richiede ~100ms. SHA-256('password123') richiede ~0.0001ms. Per password serve lento!",
                details: "Formato: $2a$cost$salt$hash. Cost factor controlla quante iterazioni (2^cost). Ogni password ha salt unico. Usato per hashare password."
            },
            {
                term: "Argon2",
                code: "Argon2",
                category: "algorithms",
                explanation: "Algoritmo di hashing per password, vincitore della Password Hashing Competition 2015. Memory-hard (resiste a GPU).",
                example: "Argon2id √® la variante raccomandata. Richiede memoria RAM, rendendo attacchi GPU meno efficaci.",
                details: "OWASP 2024 raccomanda Argon2 come prima scelta per password. Pi√π moderno di bcrypt, resistente anche ad ASIC."
            },
            {
                term: "Salt",
                code: "salt",
                category: "security",
                explanation: "Un valore casuale aggiunto alla password prima dell'hashing. Rende ogni hash unico, anche per password identiche.",
                example: "Password 'ciao' + salt1 ‚Üí hash1. Password 'ciao' + salt2 ‚Üí hash2 (diverso!). Impedisce rainbow tables.",
                details: "Il salt NON √® segreto (salvato nel database). Deve essere unico per ogni password. Lunghezza minima: 128 bit (16 byte)."
            },
            {
                term: "Rainbow Table",
                code: "rainbow table",
                category: "security",
                explanation: "Tabella pre-calcolata di hash di password comuni. Se non c'√® salt, permette di trovare password velocemente.",
                example: "Rainbow table contiene: 'password' ‚Üí hash, '123456' ‚Üí hash, ecc. Se hash password = hash in tabella ‚Üí password trovata!",
                details: "Il salt rende rainbow tables inutili: ogni password ha salt diverso, quindi serve tabella diversa per ogni salt (impossibile!)."
            },
            {
                term: "Birthday Attack",
                code: "birthday attack",
                category: "security",
                explanation: "Attacco che sfrutta il paradosso del compleanno: trovare collisioni (due input con stesso hash) √® pi√π facile di trovare preimage.",
                example: "Per SHA-256, trovare preimage richiede ~2^256 operazioni, ma trovare collisioni richiede solo ~2^128 (birthday paradox).",
                details: "Per hash di n bit, collisioni richiedono ~2^(n/2) operazioni. Ecco perch√© SHA-256 ha 256 bit: collisioni richiedono ancora 2^128 (impossibile)."
            },
            {
                term: "Collision",
                code: "collision",
                category: "security",
                explanation: "Due input diversi che producono lo stesso hash. Una buona funzione hash dovrebbe rendere le collisioni computazionalmente impossibili.",
                example: "MD5 √® rotto: √® possibile trovare due file diversi con stesso hash MD5 in secondi. SHA-256: collisioni richiedono 2^128 operazioni.",
                details: "MD5 e SHA-1 sono rotti perch√© collisioni sono trovate facilmente. SHA-256, SHA-3, BLAKE2 sono sicuri (nessuna collisione trovata)."
            },
            {
                term: "Merkle-Damg√•rd",
                code: "Merkle-Damg√•rd",
                category: "algorithms",
                explanation: "Struttura usata da SHA-256: divide l'input in blocchi, processa ogni blocco con una funzione di compressione, concatenando i risultati.",
                example: "Input ‚Üí Padding ‚Üí Blocchi 512 bit ‚Üí Compression Function ‚Üí Hash finale. SHA-256 e SHA-1 usano questa struttura.",
                details: "Vulnerabile a length extension attack. SHA-3 usa Keccak (sponge), non Merkle-Damg√•rd, quindi non ha questo problema."
            },
            {
                term: "Keccak / Sponge",
                code: "SHA-3",
                category: "algorithms",
                explanation: "Struttura diversa da Merkle-Damg√•rd usata da SHA-3. 'Sponge' perch√© assorbe input e 'spreme' output.",
                example: "SHA-3 assorbe input in uno 'sponge', poi produce output di dimensione fissa. Design completamente diverso da SHA-2.",
                details: "SHA-3 √® resistente a length extension attack e ha design moderno. Backup se SHA-2 fosse compromesso."
            },
            {
                term: "XOR (eXclusive OR)",
                code: "a ‚äï b",
                category: "operations",
                explanation: "Operazione bit a bit: 0‚äï0=0, 0‚äï1=1, 1‚äï0=1, 1‚äï1=0. L'unica operazione logica reversibile.",
                example: "1011 ‚äï 1100 = 0111. Se fai XOR due volte con stesso valore, ottieni l'originale: (a ‚äï b) ‚äï b = a.",
                details: "XOR √® usato in AddRoundKey (AES), stream ciphers, e molti altri algoritmi. √à reversibile: perfetto per crittografia."
            },
            {
                term: "GCD (Greatest Common Divisor)",
                code: "GCD(a, b)",
                category: "math",
                explanation: "Il pi√π grande numero che divide entrambi a e b. Se GCD(a,b) = 1, i numeri sono 'coprimi'.",
                example: "GCD(48, 18) = 6 perch√© 6 divide sia 48 che 18, e nessun numero pi√π grande li divide entrambi.",
                details: "Calcolato velocemente con algoritmo di Euclide. Fondamentale per verificare se due numeri sono coprimi (necessario per inverso modulare)."
            },
            {
                term: "Modulo",
                code: "a mod n",
                category: "math",
                explanation: "Il resto della divisione di a per n. Pensa all'orologio: 17 mod 12 = 5 (se sono le 17:00, l'orologio a 12 ore segna le 5:00).",
                example: "17 mod 12 = 5 perch√© 17 = 1 √ó 12 + 5. Il resto √® 5.",
                details: "Fondamentale in crittografia: RSA, Diffie-Hellman, ECDH usano tutti aritmetica modulare. 'Avvolge' i numeri in un range finito."
            },
            {
                term: "Inverso Modulare",
                code: "a‚Åª¬π mod n",
                category: "math",
                explanation: "Il numero x tale che a √ó x ‚â° 1 (mod n). Esiste solo se GCD(a, n) = 1 (a e n sono coprimi).",
                example: "L'inverso di 3 mod 11 √® 4 perch√© 3 √ó 4 = 12 ‚â° 1 (mod 11). In RSA, la chiave privata d √® l'inverso di e mod œÜ(n).",
                details: "Calcolato con algoritmo esteso di Euclide o (se n √® primo) con Fermat: a‚Åª¬π ‚â° a^(n-2) mod n."
            },
            {
                term: "Piccolo Teorema di Fermat",
                code: "a^(p-1) ‚â° 1 (mod p)",
                category: "math",
                explanation: "Se p √® primo e GCD(a, p) = 1, allora a elevato a (p-1) √® congruo a 1 modulo p.",
                example: "2^6 mod 7 = 64 mod 7 = 1. Perch√© 7 √® primo e GCD(2, 7) = 1.",
                details: "Usato per test di primalit√† e calcolo di inversi modulari. Versione generalizzata (Eulero): a^œÜ(n) ‚â° 1 (mod n) se GCD(a,n)=1."
            },
            {
                term: "Residuo Quadratico",
                code: "x¬≤ ‚â° a (mod p)",
                category: "math",
                explanation: "Un numero a √® residuo quadratico mod p se esiste un x tale che x¬≤ ‚â° a (mod p). Cio√®, a ha una 'radice quadrata' mod p.",
                example: "4 √® residuo quadratico mod 13 perch√© 2¬≤ = 4 mod 13. 5 NON √® residuo quadratico mod 13 (nessun x soddisfa x¬≤ ‚â° 5 mod 13).",
                details: "Per p primo dispari, esattamente (p-1)/2 numeri sono residui quadratici. Usato in alcuni cifrari e test di primalit√†."
            },
            {
                term: "Simbolo di Legendre",
                code: "(a/p)",
                category: "math",
                explanation: "Indica se a √® residuo quadratico mod p: (a/p) = 1 se a √® RQ, (a/p) = -1 se non √® RQ, (a/p) = 0 se p divide a.",
                example: "(2/7) = 1 perch√© 3¬≤ = 9 ‚â° 2 (mod 7). (3/7) = -1 perch√© nessun x soddisfa x¬≤ ‚â° 3 (mod 7).",
                details: "Calcolato con criterio di Eulero: (a/p) ‚â° a^((p-1)/2) mod p. Usato in test di primalit√† e alcuni cifrari."
            },
            {
                term: "CRT (Chinese Remainder Theorem)",
                code: "CRT",
                category: "math",
                explanation: "Teorema che permette di risolvere sistemi di congruenze. In RSA, usato per velocizzare la decifratura (4√ó pi√π veloce!).",
                example: "x ‚â° 2 (mod 3), x ‚â° 3 (mod 5), x ‚â° 2 (mod 7) ‚Üí x = 23 (soluzione unica mod 105).",
                details: "In RSA, invece di calcolare m = c^d mod n, calcoli m‚ÇÅ = c^d mod p e m‚ÇÇ = c^d mod q, poi combini con CRT. Molto pi√π veloce!"
            },
            {
                term: "SubBytes",
                code: "SubBytes",
                category: "operations",
                explanation: "Prima operazione di un round AES: ogni byte viene sostituito con un altro byte usando la S-box.",
                example: "Byte 0x00 ‚Üí S-box ‚Üí 0x63. Byte 0x01 ‚Üí S-box ‚Üí 0x7c. Ogni byte ha una sostituzione fissa.",
                details: "Fornisce 'confusione': rende difficile dedurre la chiave. La S-box √® non-lineare e biunivoca."
            },
            {
                term: "ShiftRows",
                code: "ShiftRows",
                category: "operations",
                explanation: "Seconda operazione AES: ogni riga della matrice 4√ó4 viene spostata ciclicamente a sinistra (riga 0: 0 pos, riga 1: 1 pos, riga 2: 2 pos, riga 3: 3 pos).",
                example: "Riga [a, b, c, d] diventa [b, c, d, a] dopo shift di 1. Mescola byte tra colonne diverse.",
                details: "Fornisce 'diffusione': un byte che era in colonna 0 pu√≤ finire in colonna 1, 2, o 3."
            },
            {
                term: "MixColumns",
                code: "MixColumns",
                category: "operations",
                explanation: "Terza operazione AES: ogni colonna viene moltiplicata per una matrice fissa in GF(2‚Å∏). Un byte influenza tutti e 4 i byte della colonna.",
                example: "Colonna [a, b, c, d] ‚Üí [a', b', c', d'] dove ogni nuovo byte dipende da tutti e 4 i byte originali.",
                details: "Fornisce 'diffusione massima'. L'ultimo round NON ha MixColumns (per rendere decifratura simmetrica)."
            },
            {
                term: "AddRoundKey",
                code: "AddRoundKey",
                category: "operations",
                explanation: "Quarta operazione AES: ogni byte viene combinato con il byte corrispondente della chiave di round usando XOR.",
                example: "Byte stato: 10110101, Byte chiave: 11001100 ‚Üí Risultato: 01111001 (XOR bit a bit).",
                details: "√à l'unica operazione che usa la chiave! XOR √® reversibile: (state ‚äï key) ‚äï key = state. Funziona sia per cifrare che decifrare."
            },
            {
                term: "PFS (Perfect Forward Secrecy)",
                code: "PFS",
                category: "security",
                explanation: "Propriet√† per cui, anche se la chiave principale viene compromessa, le comunicazioni passate rimangono sicure.",
                example: "Signal usa PFS: ogni messaggio ha chiave effimera. Se la chiave principale √® compromessa, i messaggi passati sono ancora sicuri.",
                details: "Ottenuto usando chiavi effimere (temporanee) per ogni sessione. Se la chiave principale √® compromessa, solo le comunicazioni future sono a rischio."
            },
            {
                term: "MITM (Man-In-The-Middle)",
                code: "MITM",
                category: "security",
                explanation: "Attacco dove un attaccante si interpone tra due parti che comunicano, intercettando e possibilmente modificando i messaggi.",
                example: "Alice pensa di comunicare con Bob, ma in realt√† comunica con Eve che fa da intermediario. Eve vede tutti i messaggi.",
                details: "Prevenuto con autenticazione (certificati SSL/TLS, firme digitali). PKI (Public Key Infrastructure) verifica l'identit√† delle parti."
            },
            {
                term: "PKI (Public Key Infrastructure)",
                code: "PKI",
                category: "protocols",
                explanation: "Sistema di certificati digitali che verifica l'identit√† delle parti. I certificati sono firmati da Certificate Authority (CA).",
                example: "Quando visiti https://google.com, il browser verifica il certificato SSL firmato da una CA. Se valido, la connessione √® autenticata.",
                details: "PKI risolve il problema MITM: i certificati provano che stai comunicando con la parte giusta, non con un attaccante."
            }
        ];

        function renderTerms(filteredTerms = terms) {
            const container = document.getElementById('terms-container');
            container.innerHTML = '';

            if (filteredTerms.length === 0) {
                container.innerHTML = '<p style="color: #94a3b8; text-align: center; padding: 40px;">Nessun termine trovato. Prova una ricerca diversa.</p>';
                return;
            }

            filteredTerms.forEach(term => {
                const card = document.createElement('div');
                card.className = 'term-card';
                card.setAttribute('data-category', term.category);

                const categoryNames = {
                    'math': 'Matematica',
                    'algorithms': 'Algoritmi',
                    'protocols': 'Protocolli',
                    'operations': 'Operazioni',
                    'security': 'Sicurezza'
                };

                card.innerHTML = `
                    <h3>
                        ${term.term}
                        ${term.code ? `<span class="term-code">${term.code}</span>` : ''}
                    </h3>
                    <div class="term-explanation">${term.explanation}</div>
                    ${term.example ? `<div class="term-example"><strong>Esempio:</strong> ${term.example}</div>` : ''}
                    ${term.details ? `<div class="term-explanation" style="margin-top: 10px; font-size: 0.9em; color: #64748b;">${term.details}</div>` : ''}
                    <span class="term-category">${categoryNames[term.category] || term.category}</span>
                `;

                container.appendChild(card);
            });
        }

        function filterTerms() {
            const search = document.getElementById('search-input').value.toLowerCase();
            const activeCategory = document.querySelector('.category-btn.active')?.textContent.trim().toLowerCase();

            let filtered = terms;

            // Filter by category
            if (activeCategory && activeCategory !== 'tutti') {
                const categoryMap = {
                    'matematica': 'math',
                    'algoritmi': 'algorithms',
                    'protocolli': 'protocols',
                    'operazioni': 'operations',
                    'sicurezza': 'security'
                };
                const category = categoryMap[activeCategory] || activeCategory;
                filtered = filtered.filter(t => t.category === category);
            }

            // Filter by search
            if (search) {
                filtered = filtered.filter(t =>
                    t.term.toLowerCase().includes(search) ||
                    (t.code && t.code.toLowerCase().includes(search)) ||
                    t.explanation.toLowerCase().includes(search) ||
                    (t.example && t.example.toLowerCase().includes(search))
                );
            }

            renderTerms(filtered);
        }

        function filterByCategory(category) {
            document.querySelectorAll('.category-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            filterTerms();
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            renderTerms();
        });
    </script>
</body>

</html>